#!/usr/bin/env python3
"""
漏洞验证器
提供漏洞验证的自动化测试功能
"""

import argparse
import json
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum


class ValidationStatus(Enum):
    """验证状态"""
    CONFIRMED = "confirmed"      # 已确认存在
    POTENTIAL = "potential"      # 可能存在
    FALSE_POSITIVE = "false_positive"  # 误报
    UNKNOWN = "unknown"          # 未知


@dataclass
class Vulnerability:
    """漏洞数据类"""
    id: str
    type: str
    severity: str
    file: str
    line: int
    description: str
    poc_code: Optional[str] = None


@dataclass
class ValidationResult:
    """验证结果数据类"""
    vulnerability_id: str
    status: ValidationStatus
    evidence: str
    test_output: Optional[str] = None
    remediation_verified: bool = False


class VulnerabilityValidator:
    """漏洞验证器主类"""
    
    def __init__(self, target_path: str, config: Optional[Dict] = None):
        self.target_path = Path(target_path)
        self.config = config or {}
        self.results: List[ValidationResult] = []
        
    def validate(self, vulnerabilities: List[Vulnerability]) -> List[ValidationResult]:
        """
        验证漏洞列表
        
        Args:
            vulnerabilities: 待验证的漏洞列表
            
        Returns:
            验证结果列表
        """
        print(f"[*] 开始验证 {len(vulnerabilities)} 个漏洞")
        
        for vuln in vulnerabilities:
            print(f"\n[*] 验证漏洞: {vuln.id}")
            result = self._validate_single(vuln)
            self.results.append(result)
            print(f"[+] 验证结果: {result.status.value}")
            
        return self.results
        
    def _validate_single(self, vuln: Vulnerability) -> ValidationResult:
        """验证单个漏洞"""
        # 根据漏洞类型选择验证方法
        validators = {
            'sql_injection': self._validate_sql_injection,
            'command_injection': self._validate_command_injection,
            'xss': self._validate_xss,
            'ssrf': self._validate_ssrf,
            'file_upload': self._validate_file_upload,
            'path_traversal': self._validate_path_traversal,
            'deserialization': self._validate_deserialization,
            'hardcoded_secret': self._validate_hardcoded_secret,
        }
        
        validator = validators.get(vuln.type, self._validate_generic)
        return validator(vuln)
        
    def _validate_sql_injection(self, vuln: Vulnerability) -> ValidationResult:
        """验证 SQL 注入漏洞"""
        print(f"  [-] 检查 SQL 注入: {vuln.file}:{vuln.line}")
        
        # 读取代码
        code = self._read_code(vuln.file, vuln.line)
        if not code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码文件"
            )
            
        # 检查是否存在 SQL 拼接
        sql_patterns = [
            r'execute\s*\(\s*["\'].*\+',
            r'query\s*\(\s*["\'].*\+',
            r'raw\s*\(\s*["\'].*\+',
            r'\$\{.*\}',
            r'%s.*%',
        ]
        
        import re
        found_pattern = False
        for pattern in sql_patterns:
            if re.search(pattern, code, re.IGNORECASE):
                found_pattern = True
                break
                
        if found_pattern:
            # 尝试构建 POC
            poc = self._build_sql_poc(code)
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.CONFIRMED,
                evidence=f"发现 SQL 拼接模式: {code[:100]}...",
                test_output=poc
            )
        else:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.FALSE_POSITIVE,
                evidence="未发现 SQL 拼接模式，可能是误报"
            )
            
    def _validate_command_injection(self, vuln: Vulnerability) -> ValidationResult:
        """验证命令注入漏洞"""
        print(f"  [-] 检查命令注入: {vuln.file}:{vuln.line}")
        
        code = self._read_code(vuln.file, vuln.line)
        if not code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码文件"
            )
            
        # 检查危险函数
        dangerous_funcs = ['exec', 'system', 'shell_exec', 'popen', 'proc_open']
        if any(func in code for func in dangerous_funcs):
            # 检查是否有用户输入拼接
            if any(char in code for char in ['+', '${', '%s']):
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.CONFIRMED,
                    evidence=f"发现命令注入风险: {code[:100]}...",
                    test_output=self._build_cmd_poc(code)
                )
                
        return ValidationResult(
            vulnerability_id=vuln.id,
            status=ValidationStatus.POTENTIAL,
            evidence="发现危险函数，但需要进一步验证"
        )
        
    def _validate_xss(self, vuln: Vulnerability) -> ValidationResult:
        """验证 XSS 漏洞"""
        print(f"  [-] 检查 XSS: {vuln.file}:{vuln.line}")
        
        code = self._read_code(vuln.file, vuln.line)
        if not code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码文件"
            )
            
        # 检查输出函数
        output_funcs = ['echo', 'print', 'document.write', 'innerHTML']
        if any(func in code for func in output_funcs):
            # 检查是否有转义
            if 'htmlspecialchars' in code or 'escape' in code or 'sanitize' in code:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.FALSE_POSITIVE,
                    evidence="发现输出函数，但存在转义处理"
                )
            else:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.CONFIRMED,
                    evidence=f"发现未转义的输出: {code[:100]}...",
                    test_output="<script>alert('XSS')</script>"
                )
                
        return ValidationResult(
            vulnerability_id=vuln.id,
            status=ValidationStatus.POTENTIAL,
            evidence="需要进一步分析"
        )
        
    def _validate_ssrf(self, vuln: Vulnerability) -> ValidationResult:
        """验证 SSRF 漏洞"""
        print(f"  [-] 检查 SSRF: {vuln.file}:{vuln.line}")
        
        code = self._read_code(vuln.file, vuln.line)
        if not code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码文件"
            )
            
        # 检查 HTTP 请求
        http_patterns = ['http', 'url', 'request', 'curl', 'wget']
        if any(pattern in code.lower() for pattern in http_patterns):
            # 检查是否有 URL 验证
            if 'whitelist' in code or 'validate' in code or 'allow' in code:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.FALSE_POSITIVE,
                    evidence="发现 URL 验证机制"
                )
            else:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.CONFIRMED,
                    evidence=f"发现未验证的 URL 请求: {code[:100]}...",
                    test_output="http://169.254.169.254/latest/meta-data/"
                )
                
        return ValidationResult(
            vulnerability_id=vuln.id,
            status=ValidationStatus.POTENTIAL,
            evidence="需要进一步分析"
        )
        
    def _validate_file_upload(self, vuln: Vulnerability) -> ValidationResult:
        """验证文件上传漏洞"""
        print(f"  [-] 检查文件上传: {vuln.file}:{vuln.line}")
        
        code = self._read_code(vuln.file, vuln.line)
        if not code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码文件"
            )
            
        # 检查文件上传处理
        upload_funcs = ['move_uploaded_file', 'transferTo', 'save']
        if any(func in code for func in upload_funcs):
            # 检查扩展名验证
            if any(check in code for check in ['extension', 'mime', 'type']):
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.POTENTIAL,
                    evidence="发现文件上传验证，但需要验证验证逻辑"
                )
            else:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.CONFIRMED,
                    evidence=f"发现无验证的文件上传: {code[:100]}...",
                    test_output="shell.php"
                )
                
        return ValidationResult(
            vulnerability_id=vuln.id,
            status=ValidationStatus.UNKNOWN,
            evidence="无法确定文件上传逻辑"
        )
        
    def _validate_path_traversal(self, vuln: Vulnerability) -> ValidationResult:
        """验证路径遍历漏洞"""
        print(f"  [-] 检查路径遍历: {vuln.file}:{vuln.line}")
        
        code = self._read_code(vuln.file, vuln.line)
        if not code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码文件"
            )
            
        # 检查文件操作
        file_funcs = ['open', 'readFile', 'file_get_contents', 'include', 'require']
        if any(func in code for func in file_funcs):
            # 检查路径验证
            if 'realpath' in code or 'basename' in code or 'sanitize' in code:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.FALSE_POSITIVE,
                    evidence="发现路径验证机制"
                )
            elif '..' in code or './' in code:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.CONFIRMED,
                    evidence=f"发现路径遍历风险: {code[:100]}...",
                    test_output="../../../etc/passwd"
                )
                
        return ValidationResult(
            vulnerability_id=vuln.id,
            status=ValidationStatus.POTENTIAL,
            evidence="需要进一步分析"
        )
        
    def _validate_deserialization(self, vuln: Vulnerability) -> ValidationResult:
        """验证反序列化漏洞"""
        print(f"  [-] 检查反序列化: {vuln.file}:{vuln.line}")
        
        code = self._read_code(vuln.file, vuln.line)
        if not code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码文件"
            )
            
        # 检查反序列化函数
        deserialize_funcs = [
            'readObject', 'unserialize', 'pickle.loads',
            'yaml.load', 'json.loads', 'fromXML'
        ]
        
        if any(func in code for func in deserialize_funcs):
            # 检查是否有白名单验证
            if 'whitelist' in code or 'validate' in code or 'check' in code:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.POTENTIAL,
                    evidence="发现反序列化验证，但需要验证验证逻辑"
                )
            else:
                return ValidationResult(
                    vulnerability_id=vuln.id,
                    status=ValidationStatus.CONFIRMED,
                    evidence=f"发现未验证的反序列化: {code[:100]}...",
                    test_output=self._build_deser_poc(vuln.type)
                )
                
        return ValidationResult(
            vulnerability_id=vuln.id,
            status=ValidationStatus.UNKNOWN,
            evidence="无法确定反序列化逻辑"
        )
        
    def _validate_hardcoded_secret(self, vuln: Vulnerability) -> ValidationResult:
        """验证硬编码密钥"""
        print(f"  [-] 检查硬编码密钥: {vuln.file}:{vuln.line}")
        
        code = self._read_code(vuln.file, vuln.line)
        if not code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码文件"
            )
            
        # 检查是否是配置文件中的示例
        if 'example' in code.lower() or 'demo' in code.lower() or 'test' in code.lower():
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.FALSE_POSITIVE,
                evidence="可能是示例/测试密钥"
            )
            
        # 检查密钥复杂度
        import re
        key_pattern = r'[\w\-]{16,}'
        matches = re.findall(key_pattern, code)
        
        if matches:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.CONFIRMED,
                evidence=f"发现硬编码密钥: {matches[0][:20]}...",
                test_output="建议移至环境变量或密钥管理系统"
            )
            
        return ValidationResult(
            vulnerability_id=vuln.id,
            status=ValidationStatus.POTENTIAL,
            evidence="需要进一步分析"
        )
        
    def _validate_generic(self, vuln: Vulnerability) -> ValidationResult:
        """通用验证方法"""
        print(f"  [-] 通用验证: {vuln.file}:{vuln.line}")
        
        code = self._read_code(vuln.file, vuln.line)
        if code:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.POTENTIAL,
                evidence=f"代码片段: {code[:100]}...",
                test_output="需要手动验证"
            )
        else:
            return ValidationResult(
                vulnerability_id=vuln.id,
                status=ValidationStatus.UNKNOWN,
                evidence="无法读取代码"
            )
            
    def _read_code(self, file_path: str, line_number: int, context: int = 3) -> Optional[str]:
        """读取代码片段"""
        try:
            full_path = self.target_path / file_path
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
                
            start = max(0, line_number - context - 1)
            end = min(len(lines), line_number + context)
            
            return ''.join(lines[start:end])
        except Exception as e:
            print(f"  [!] 读取文件失败: {e}")
            return None
            
    def _build_sql_poc(self, code: str) -> str:
        """构建 SQL 注入 POC"""
        return "' OR '1'='1' -- "
        
    def _build_cmd_poc(self, code: str) -> str:
        """构建命令注入 POC"""
        return "; cat /etc/passwd; #"
        
    def _build_deser_poc(self, lang: str) -> str:
        """构建反序列化 POC"""
        pocs = {
            'java': 'O:8:"stdClass":0:{}',
            'python': "pickle.loads(b'cos\\nsystem\\n(S\"whoami\"\\ntR.')",
            'php': 'O:8:"stdClass":0:{}'
        }
        return pocs.get(lang, '需要针对语言构造 POC')
        
    def export_results(self, output_path: str):
        """导出验证结果"""
        data = []
        for result in self.results:
            data.append({
                'vulnerability_id': result.vulnerability_id,
                'status': result.status.value,
                'evidence': result.evidence,
                'test_output': result.test_output,
                'remediation_verified': result.remediation_verified
            })
            
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
            
        print(f"\n[+] 验证结果已导出: {output_path}")
        
    def print_summary(self):
        """打印验证摘要"""
        print("\n" + "="*50)
        print("验证摘要")
        print("="*50)
        
        status_count = {}
        for result in self.results:
            status = result.status.value
            status_count[status] = status_count.get(status, 0) + 1
            
        for status, count in status_count.items():
            print(f"  {status}: {count}")
            
        confirmed = status_count.get('confirmed', 0)
        total = len(self.results)
        print(f"\n确认率: {confirmed}/{total} ({confirmed/total*100:.1f}%)")


def main():
    parser = argparse.ArgumentParser(
        description='漏洞验证工具',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
示例:
  %(prog)s /path/to/project --input vuln.json
  %(prog)s /path/to/project --input vuln.json --output result.json
        """
    )
    
    parser.add_argument('target', help='目标项目路径')
    parser.add_argument(
        '--input', '-i',
        required=True,
        help='漏洞列表 JSON 文件'
    )
    parser.add_argument(
        '--output', '-o',
        default='validation_result.json',
        help='输出结果文件'
    )
    
    args = parser.parse_args()
    
    # 读取漏洞列表
    with open(args.input, 'r', encoding='utf-8') as f:
        vuln_data = json.load(f)
        
    vulnerabilities = []
    for item in vuln_data:
        vulnerabilities.append(Vulnerability(
            id=item.get('id', 'unknown'),
            type=item.get('type', 'unknown'),
            severity=item.get('severity', 'medium'),
            file=item.get('file', ''),
            line=item.get('line', 0),
            description=item.get('description', ''),
            poc_code=item.get('poc_code')
        ))
        
    # 创建验证器并执行验证
    validator = VulnerabilityValidator(args.target)
    validator.validate(vulnerabilities)
    
    # 导出结果
    validator.export_results(args.output)
    
    # 打印摘要
    validator.print_summary()
    
    return 0


if __name__ == '__main__':
    sys.exit(main())
