# 漏洞案例库

> **本文档用途**: 按漏洞类型分类的真实案例集合  
> **目标读者**: 安全审计人员、开发人员  
> **内容特点**: 实际代码示例 + 攻击Payload + 修复方案  
> **相关文档**:
> - [漏洞分析方法](vulnerability-analysis.md) - 学习如何分析漏洞
> - [攻击链与POC](detailed-vulnerability-chains.md) - 详细的攻击步骤和POC

---

## 1. 注入类漏洞案例

### 1.1 SQL注入案例

#### 案例1.1.1: 基于字符串拼接的SQL注入
**漏洞类型**：SQL注入
**严重程度**：High
**影响范围**：数据泄露、数据篡改

**漏洞代码**：
```java
// UserController.java
@GetMapping("/users/{id}")
public User getUserById(@PathVariable Long id) {
    String sql = "SELECT * FROM users WHERE id = " + id;
    return jdbcTemplate.query(sql, new UserRowMapper());
}
```

**攻击Payload**：
```bash
# 联合查询注入
curl -X GET "http://example.com/api/users/1 UNION SELECT username, password FROM admin_users"

# 盲注
curl -X GET "http://example.com/api/users/1 AND 1=1"

# 时间盲注
curl -X GET "http://example.com/api/users/1 AND SLEEP(5)"
```

**修复方案**：
```java
@GetMapping("/users/{id}")
public User getUserById(@PathVariable Long id) {
    String sql = "SELECT * FROM users WHERE id = ?";
    return jdbcTemplate.queryForObject(sql, new Object[]{id}, new UserRowMapper());
}
```

#### 案例1.1.2: 不安全ORM使用
**漏洞类型**：SQL注入
**严重程度**：Medium
**影响范围**：数据泄露

**漏洞代码**：
```python
# user_service.py
def get_users_by_role(role_name):
    query = f"SELECT * FROM users WHERE role = '{role_name}'"
    return db.execute(query).fetchall()
```

**攻击Payload**：
```bash
# 条件注入
curl -X GET "http://example.com/api/users?role=admin' OR '1'='1"

# 注释注入
curl -X GET "http://example.com/api/users?role=admin'--"
```

**修复方案**：
```python
def get_users_by_role(role_name):
    query = "SELECT * FROM users WHERE role = %s"
    return db.execute(query, (role_name,)).fetchall()
```

### 1.2 命令注入案例

#### 案例1.2.1: Runtime.exec命令注入
**漏洞类型**：命令注入
**严重程度**：Critical
**影响范围**：远程代码执行

**漏洞代码**：
```java
// CommandExecutor.java
public void executeCommand(String command) {
    try {
        Runtime.getRuntime().exec("ping " + command);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

**攻击Payload**：
```bash
# 命令分隔符
curl -X POST "http://example.com/api/execute" -d "command=example.com; cat /etc/passwd"

# 管道注入
curl -X POST "http://example.com/api/execute" -d "command=example.com | whoami"

# 反引号注入
curl -X POST "http://example.com/api/execute" -d "command=example.com`whoami`"
```

**修复方案**：
```java
public void executeCommand(String[] command) {
    try {
        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        Process process = pb.start();
        int exitCode = process.waitFor();
        if (exitCode != 0) {
            throw new RuntimeException("Command execution failed");
        }
    } catch (IOException | InterruptedException e) {
        throw new RuntimeException("Command execution error", e);
    }
}
```

#### 案例1.2.2: subprocess命令注入
**漏洞类型**：命令注入
**严重程度**：High
**影响范围**：远程代码执行

**漏洞代码**：
```python
# command_executor.py
import subprocess

def execute_command(user_input):
    command = f"ping {user_input}"
    result = subprocess.run(command, shell=True, capture_output=True)
    return result.stdout
```

**攻击Payload**：
```bash
# 命令注入
curl -X POST "http://example.com/api/execute" -d "input=example.com; cat /etc/passwd"

# 反引号注入
curl -X POST "http://example.com/api/execute" -d "input=example.com`whoami`"
```

**修复方案**：
```python
import subprocess

def execute_command(user_input):
    if not is_valid_input(user_input):
        raise ValueError("Invalid input")
    
    command = ["ping", user_input]
    result = subprocess.run(command, shell=False, capture_output=True)
    return result.stdout
```

### 1.3 XSS案例

#### 案例1.3.1: 存储型XSS
**漏洞类型**：XSS
**严重程度**：Medium
**影响范围**：会话劫持、数据窃取

**漏洞代码**：
```javascript
// CommentController.java
@PostMapping("/comments")
public String addComment(@RequestBody Comment comment) {
    commentService.save(comment);
    return "redirect:/comments";
}
```

```html
<!-- comments.html -->
<div class="comment">
    <p>${comment.content}</p>
</div>
```

**攻击Payload**：
```html
<script>
// 存储XSS攻击
fetch('http://example.com/api/comments', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
        content: '<script>alert(document.cookie)</script>'
    })
});
</script>
```

**修复方案**：
```html
<div class="comment">
    <p>${comment.content?html}</p>
</div>
```

#### 案例1.3.2: 反射型XSS
**漏洞类型**：XSS
**严重程度**：Medium
**影响范围**：会话劫持、数据窃取

**漏洞代码**：
```java
// SearchController.java
@GetMapping("/search")
public String search(@RequestParam String query, Model model) {
    model.addAttribute("query", query);
    return "search-results";
}
```

```html
<!-- search-results.html -->
<div class="results">
    <p>搜索结果: ${query}</p>
</div>
```

**攻击Payload**：
```bash
# 反射型XSS攻击
curl -X GET "http://example.com/search?query=<script>alert(document.cookie)</script>"
```

**修复方案**：
```html
<div class="results">
    <p>搜索结果: ${query?html}</p>
</div>
```

### 1.4 认证绕过案例

#### 案例1.4.1: 逻辑错误认证绕过
**漏洞类型**：认证绕过
**严重程度**：Critical
**影响范围**：未授权访问

**漏洞代码**：
```java
// AuthService.java
public boolean authenticate(String username, String password) {
    User user = userRepository.findByUsername(username);
    if (user != null && user.getPassword().equals(password)) {
        return true;
    }
    return false;
}
```

**攻击Payload**：
```bash
# 逻辑错误攻击
curl -X POST "http://example.com/api/login" -d "username=admin&password=wrong"
curl -X POST "http://example.com/api/login" -d "username=admin'--&password=wrong"
```

**修复方案**：
```java
public boolean authenticate(String username, String password) {
    User user = userRepository.findByUsername(username);
    if (user == null) {
        return false;
    }
    
    String hashedPassword = hashPassword(password);
    return hashedPassword.equals(user.getPassword());
}
```

#### 案例1.4.2: 配置错误认证绕过
**漏洞类型**：认证绕过
**严重程度**：Critical
**影响范围**：未授权访问

**漏洞代码**：
```java
// SecurityConfig.java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/api/admin/**").permitAll()  // 管理接口未认证
            .anyRequest().authenticated()
        .and()
        .formLogin();
}
```

**攻击Payload**：
```bash
# 未授权访问
curl -X GET "http://example.com/api/admin/users"
curl -X GET "http://example.com/api/admin/config"
```

**修复方案**：
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/api/admin/**").hasRole("ADMIN")  // 添加角色检查
            .anyRequest().authenticated()
        .and()
        .formLogin();
}
```

### 1.5 路径遍历案例

#### 案例1.5.1: 文件读取路径遍历
**漏洞类型**：路径遍历
**严重程度**：High
**影响范围**：任意文件读取

**漏洞代码**：
```java
// FileController.java
@GetMapping("/files/{filename}")
public ResponseEntity<Resource> getFile(@PathVariable String filename) {
    File file = new File("/var/www/uploads/" + filename);
    Resource resource = new FileSystemResource(file);
    return ResponseEntity.ok()
            .contentType(MediaType.APPLICATION_OCTET_STREAM)
            .body(resource);
}
```

**攻击Payload**：
```bash
# 路径遍历攻击
curl -X GET "http://example.com/api/files/../../../etc/passwd"
curl -X GET "http://example.com/api/files/..%2F..%2F..%2Fetc%2Fpasswd"
```

**修复方案**：
```java
@GetMapping("/files/{filename}")
public ResponseEntity<Resource> getFile(@PathVariable String filename) {
    if (!isValidFilename(filename)) {
        return ResponseEntity.badRequest().build();
    }
    
    Path filePath = Paths.get("/var/www/uploads/").resolve(filename).normalize();
    if (!filePath.startsWith("/var/www/uploads/")) {
        return ResponseEntity.badRequest().build();
    }
    
    File file = filePath.toFile();
    Resource resource = new FileSystemResource(file);
    return ResponseEntity.ok()
            .contentType(MediaType.APPLICATION_OCTET_STREAM)
            .body(resource);
}
```

### 1.6 SSRF案例

#### 案例1.6.1: URL可控SSRF
**漏洞类型**：SSRF
**严重程度**：High
**影响范围**：内网扫描、数据泄露

**漏洞代码**：
```java
// ProxyController.java
@GetMapping("/proxy")
public String proxy(@RequestParam String url) throws IOException {
    URL targetUrl = new URL(url);
    HttpURLConnection connection = (HttpURLConnection) targetUrl.openConnection();
    connection.setRequestMethod("GET");
    
    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    StringBuilder response = new StringBuilder();
    String line;
    while ((line = reader.readLine()) != null) {
        response.append(line);
    }
    
    return response.toString();
}
```

**攻击Payload**：
```bash
# 内网扫描
curl -X GET "http://example.com/api/proxy?url=http://192.168.1.1:22"
curl -X GET "http://example.com/api/proxy?url=http://localhost:8080"

# 云元数据访问
curl -X GET "http://example.com/api/proxy?url=http://169.254.169.254/latest/meta-data/"
```

**修复方案**：
```java
@GetMapping("/proxy")
public String proxy(@RequestParam String url) throws IOException {
    if (!isValidUrl(url)) {
        throw new IllegalArgumentException("Invalid URL");
    }
    
    URL targetUrl = new URL(url);
    String host = targetUrl.getHost();
    
    if (isInternalIp(host)) {
        throw new IllegalArgumentException("Internal IP not allowed");
    }
    
    HttpURLConnection connection = (HttpURLConnection) targetUrl.openConnection();
    connection.setRequestMethod("GET");
    
    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    StringBuilder response = new StringBuilder();
    String line;
    while ((line = reader.readLine()) != null) {
        response.append(line);
    }
    
    return response.toString();
}
```

### 1.7 文件上传案例

#### 案例1.7.1: 不安全的文件上传
**漏洞类型**：文件上传
**严重程度**：High
**影响范围**：任意文件上传、WebShell

**漏洞代码**：
```java
// UploadController.java
@PostMapping("/upload")
public String uploadFile(@RequestParam MultipartFile file) throws IOException {
    String filename = file.getOriginalFilename();
    File uploadDir = new File("/var/www/uploads/");
    File destination = new File(uploadDir, filename);
    file.transferTo(destination);
    return "File uploaded: " + filename;
}
```

**攻击Payload**：
```bash
# WebShell上传
curl -X POST "http://example.com/api/upload" -F "file=@shell.php"

# 双重扩展名攻击
curl -X POST "http://example.com/api/upload" -F "file=@shell.php.jpg"

# NULL字节注入
curl -X POST "http://example.com/api/upload" -F "file=@shell.php\x00.jpg"
```

**修复方案**：
```java
@PostMapping("/upload")
public String uploadFile(@RequestParam MultipartFile file) throws IOException {
    String originalFilename = file.getOriginalFilename();
    String extension = getFileExtension(originalFilename);
    
    if (!isAllowedExtension(extension)) {
        throw new IllegalArgumentException("File type not allowed");
    }
    
    String safeFilename = generateSafeFilename(originalFilename);
    File uploadDir = new File("/var/www/uploads/");
    File destination = new File(uploadDir, safeFilename);
    file.transferTo(destination);
    
    return "File uploaded: " + safeFilename;
}
```

## 2. 漏洞修复最佳实践

### 2.1 通用修复原则
1. **输入验证**：对所有用户输入进行严格验证
2. **输出编码**：对所有输出进行适当的编码
3. **最小权限**：遵循最小权限原则
4. **防御纵深**：实施多层安全控制
5. **安全默认**：使用安全的默认配置
6. **持续监控**：实施安全监控和日志记录

### 2.2 技术栈特定修复
1. **Java**：使用PreparedStatement、避免Runtime.exec、使用Spring Security
2. **Python**：使用参数化查询、避免shell=True、使用Flask安全功能
3. **JavaScript**：使用模板自动转义、避免eval、实施CSP
4. **PHP**：使用PDO预处理、避免eval、使用htmlspecialchars

### 2.3 测试验证
1. **单元测试**：编写安全相关的单元测试
2. **集成测试**：进行安全相关的集成测试
3. **渗透测试**：进行专业的渗透测试
4. **代码审查**：进行安全代码审查